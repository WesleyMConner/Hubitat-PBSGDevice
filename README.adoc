
= Hubitat-PbsgLibrary
Hubitat-compatible code written for Hubitat's Groovy sandbox environment.

lPBSG.groovy::
Hubitat functions that can be incorporated into downstream applications
via `#include wesmc.lPBSG`. The functions collectively implement
*PushButton Switch Group (PBSG)* instances where each PBSG instance:

* Creates and manages a group of Virtual Switches (VSWs) - one per _pushbutton_.
* Turns off peer VSWs when one of the participating VSWs is turned on.
* Turns on a default VSW (if specified) when no participating VSW is turned on.
* Provides a `turnOnPrior()` method to restore the last active VSW.

Demo-PBSG.groovy::
Hubitat-compatible application source code that illustrates:

* Creating PBSG instances via a GUI.
* Creating PBSG instances via a configuration Map.
* Pushbutton methods and callbacks.

lPBSG.zip::
A _Hubitat Bundle_ for installing the `lPBSG.groovy` Hubitat library and the
`Demo-PBSG.groovy` Hubitat application.

packageManifest.json::
Provided to install the lOBSG.zip bundle via the moniker `WesMC-PBSGLibrary` in
https://hubitatpackagemanager.hubitatcommunity.com/[Hubitat Package Manager (HPM)].

== Creating PBSG Instances
The `Demo-PBSG` application illustrates how PBSG instances can be created
(1) by soliciting data via an Application user interfaces or (2) by providing
in-kind data via a configuration Map instance.

== Rationale for Technology Choices

=== Use of a Callback Function in lieu of emitting an Event
TBD

=== One Child VSW per PBSG "Button"

PROS::

* Unlike pushable buttons or scenes, VSWs can be turned on|off by
Alexa, Google Home, AirPlay, Hubitat rules, peer applications, etc.

CONS::

* At scale, creating several PBSG instances (each with
fully-independent buttons) results in a plethora of VSWs. As of Q2'24, newly
created VSWs have `Enable debug logging` and `Enable descriptionText logging`
enabled with no API for creating quieter VSWs.

=== Each PBSG Instance Name has a top-level Hubitat State Map Entry

PROS::

* Each PBSG instance is an independent Map - which can be treated like an
instance of a class (even though operating in Hubitat's sandboxed environment).

* Operations on a PBSG instance are efficient thanks to the use of atomicState
and atomicState.updateMapValue(...).

* Downstream psuedo-classes can be created by expanding the keys in a PBSG's
instance Map. For example: Room's may have mutually-independent scenes where
each Room instance is a PBSG instance with extra keys and methods that operate
on those keys.

CONS::

* PBSG Names must be sufficiently unique to avoid collisions in the App's
state|atomicState.