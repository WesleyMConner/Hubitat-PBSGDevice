// ---------------------------------------------------------------------------------
// P ( U S H )   B ( U T T O N )   S ( W I T C H )   G ( R O U P )
//
// Copyright (C) 2023-Present Wesley M. Conner
//
// LICENSE
// Licensed under the Apache License, Version 2.0 (aka Apache-2.0, the
// "License"), see http://www.apache.org/licenses/LICENSE-2.0. You may
// not use this file except in compliance with the License. Unless
// required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.
// ---------------------------------------------------------------------------------
#include wesmc.lUtils
#include wesmc.lPBSG

metadata {
  definition(
    // Map keys per https://docs2.hubitat.com/en/developer/driver/overview
    name: 'PBSG',
    namespace: 'wesmc',
    author: 'Wesley M. Conner',
    importUrl: 'PENDING',
    singleThreaded: 'true'
  ) {
    // Closute per https://docs2.hubitat.com/en/developer/driver/overview with:
    // capabilities, commands, attributes, and/or fingerprints
    capability "PushableButton"  // Attributes
                                 //   - numberOfButtons: number
                                 //   - pushed: number
                                 // Methods
                                 //   - push(number)
    // command "configure"
    // attribute "tbd"
  }
  preferences {
    // The following inputs:
    //   - Correspond to settings."${name}" (or `name` for short).
    //   - Are readable/writable on Hubitat's device drilldown page.
    //   - The settings function as configuration data for the driver.
    input(
      name: 'buttonsString',
      title: 'Space-delimited list of button names',
      type: 'text',
      required: true
    )
    input(
      name: 'numberOfButtons',
      title: 'Button count in buttonsString',
      type: 'number',
      defaultValue: buttonsString?.tokenize(' ')?.size(),
      required: true
    )
    input(
      name: "dflt",
      title: "Default button",
      type: "enum",
      multiple: false,
      options: [*buttonNames?.tokenize(' '), 'not applicable'],
      defaultValue: 'not applicable',
      required: true
    )
    input(
      name: "instType",
      title: "Type of PBSG",
      type: "text",
      defaultValue: "pbsg",
      required: true
    )
    input(
      name: "logLevel",
      title: "Logging Threshold Level",
      type: "enum",
      multiple: false,
      options: ['TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR'],
      defaultValue: 'INFO',
      required: true
    )
  }
}

// Per https://docs2.hubitat.com/en/developer/driver/overview,
// device data can be managed using state and/or atomicState

void installed() {
  // Configure the device's static structure w/out initiating activity.
  logInfo('installed', ['',
    settings.collect{k, v -> "${b(k)}: ${v}"}.join('<br/>')
  ].join('<br/>'))
}

void uninstalled() {
  logInfo('uninstalled', ['',
    settings.collect{k, v -> "${b(k)}: ${v}"}.join('<br/>')
  ].join('<br/>'))
}

void updated() {
  // Called when "Save" is clicked the device UI's preferences section.
  logInfo('updated', ['',
    settings.collect{k, v -> "${b(k)}: ${v}"}.join('<br/>')
  ].join('<br/>'))
}

void initialize() {
  setLogLevel(settings."${logLevel}")
  ArrayList allButtons = settings.buttonsString?.tokenize(' ')
  if (allButtons) {
    if (allButtons.size() != settings.numberOfButtons) {
      logWarn(
        'initialize',
        "Adjusting numberOfButtons from ${settings.buttonsString} to ${buttons.size()}"
      )
      settings.numberOfButtons = allButtons.size()
      logInfo('initialize', "dflt: ${settings.dflt}")
    }
    pbsg_BuildToConfig([
      name: name,                   // The name of this PBSG
      instType: settings.instType,
      all: allButtons,              // The buttons included in the PBSG
      dflt: settings.dlft
    ])
  } else {
    logError('initialize', 'Insufficient Config data')
  }
}

/*
void initialize() {
  // Core PBSG configuration fields include:
  //       pbsgName - From preferences
  //  state.buttons - Derived from buttonNames in preferences
  //       instType - From preferences
  //           dflt - From preferences
  // Core PBSG fields (in device state) include:
  //         active - Currently active PBSG button
  //           lifo - ArrayList as Last In First Out construct
  // bNumberToBName - Map of button numbers to button names
  // NOTE
  //   - "numberOfButtons" (see Preferences) is required by the
  //     PushableButton capability. Tests below ensure its value
  //     is consistent with state.buttons as extracted from
  //     "buttonNames" (see Preferences).
  setLogLevel(logLevel)
  logInfo('initialize', [
    "state: ${state}",
    "pbsgName: ${pbsgName}",
    "buttonNames: ${buttonNames}",
    "numberOfButtons: ${numberOfButtons}",
    "dflt: ${dflt}",
    "logLevel: ${logLevel}",
    "instType: ${instType}"
  ])
  if (!pbsgName) {
    logError('initialize', 'Missing required preference pbsgName')
  }
  state.buttonNames = buttonStringToButtonList(buttonNames)
  if (state.buttonNames.size() != numberOfButtons) {
    logError('installed', ['',
      "${b('numberOfButtons')} does not match ${b('buttonNames')}",
      "${all} (size=${all.size()})"
    ].join('<br/>'))
  }
  if (!dflt) {
    logWarn('initialize', 'No default button was specified')
  }
  // Configure initial state
  state.active = null
  state.lifo = []
  // Button numbers are mapped to button names to support push(index).
  state.bNumberToBName = all.withIndex().collectEntries { button, i ->
    [ i, button ]
  }
  state.buttons.each { button ->
    if (button) {
      String dni = "${state.name}_${button}"
      DevW vsw = fetchVsw(dni)
      state.lifo.push(button)
      if (switchState(vsw) == 'on') {
        // Move the button from the LIFO to active
        logInfo('buildToConfig', "Found VSW ${dni} (${b('on')})")
        activateButton(button)
      } else {
        logInfo('buildToConfig', "VSW ${dni} (${i('off')})")
      }
      subscribe(vsw, 'switch', childVswEventHandler, ['filterEvents': true])
    } else {
      logError('buildToConfig', "Encountered a null in state.buttons (${state.buttons})")
    }
  }
  if (!state.active) { enforceDefault(pbsg) }
  syncVswsAndIssueCallback()  // Save to atomicState and issue client callback
}
*/

// Externally-called methods


// Process externally-called child methods

void vswWithToggleOn(DevW d) {
  String button = vswToButtonName(d)
  activateButton(button)
}

void vswWithToggleOff(DevW d) {
  String button = vswToButtonName(d)
  deactivateButton(button)
}

void vswWithTogglePush(DevW d) {
  String button = vswToButtonName(d)
  (active == button)
    ? deactivateButton(button)
    : activateButton(button)
}

// Manage child device lifecycle
/*
DevW fetchVswWithToggle(String button) {
  String dni = "${name}_${button}" // DNI (no white space)
  DevW d = getChildDevice(dni)
  if (!d) {
    logWarn('fetchVsw', "Creating VswWithToggle ${b(dni)}")
    d = addChildDevice(
      'wesmc',          // Namespace
      'VswWithToggle',  // Device Type
      dni,              // DNI
      [
        isComponent: true,              // Bound to PBSG
        name: dni.replaceAll('_', ' ')  // Name (no special chars)
      ]
    )
  }
  return d
}
*/

/*
String vswToButtonName(DevW d) {
  // DNI has form "${pbsgName}_${button}"
  return d.getDeviceNetworkId().tokenize('_')[1]
}
*/

/*
String switchState(DevW d) {
  return d.currentValue('switch', true) // true -> Do not use the cache
}
*/

/*
void pruneOrphanedDevices() {
  logError('pruneOrphanedDevices', 'NOT YET IMPLEMENTED')
}
*/

// Child device state is adjusted by sending a list of parsable
// actions where each action is a Map that is compatible with
// sendEvent(Map) with Map keys:
//             name: device attribute
//            value: attribute's value
//             unit: Omitted if boolean, '%', ...
//  descriptionText: Human-friendly string
//    isStateChange: true|false

void turnOnVsw(String button) {
  DevW d = fetchVswWithToggle(button)
  d.parse([
    name: 'switch',
    value: 'on',
    descriptionText: "${d.name} was turned on",
    isStateChange: true
  ])
}

void turnOffVsw(String button) {
  DevW d = fetchVswWithToggle(button)
  d.parse([
    name: 'switch',
    value: 'off',
    descriptionText: "${d.name} was turned off",
    isStateChange: true
  ])
}

// The PBSG DOES NOT expect to receive directed actions via parse()

void parse(String text) {
  logWarn('parse', "parse(String) ignored:<br/>'${text}'<")
  return null
}

void parse(ArrayList actions) {
  logWarn('parse', ['parse(ArrayList) ignored:',
    actions.join('<br/>')
  ].join('<br/>'))
}

// Support for capability "PushableButton"

void push(Integer buttonNumber) {
  String button = state.bNumberToBName[buttonNumber]
  logInfo('push', "Received ${button} (#${buttonNumber})")
  activateButton(button) && syncVswsAndIssueCallback()
}

// Internal methods

boolean activateButton(String button) {
  // Assumed: pbsg != null
  // Returns true on a PBSG state change
  boolean result = false
  if (state.active == button) {
    logWarn('activateButton', "${b(button)} was already activated")
  } else {
    if (state.active) {
      state.lifo.push(state.active)
      result = true
    }
    if (state.lifo.contains(button)) {
      state.active = button
      state.lifo.removeAll([button])
      result = true
    } else {
      logError('activateButton', "Unable to find button ${b(button)}")
      // The PBSG's state is NOT changed.
    }
  }
  return result
}

boolean deactivateButton(String button) {
  // Assumed: pbsg != null
  // Returns true on a PBSG state change
  boolean result = false
  if (button == state.dflt) {
    logWarn(
      'deactivateButton',
      "Ignoring the requested deactivation of default button ${b(button)}"
    )
  } else if (state.active == button) {
    if (state.dflt) {
      // Swap currentlt active button with default button
      logTrace('pbsg_Deactivate', "Activating default ${b(state.dflt)}")
      activateButton(state.dflt)
    } else {
      // Deactivate active button only
      state.lifo.push(state.active)
    }
    result = true
  } else if (state.lifo.contains(button)) {
    logWarn('deactivateButton', "${b(button)} was already deactivated")
  } else {
    logError('deactivateButton', "${b(button)} was not found")
  }
  return result
}

void syncVswsAndIssueCallback() {
  // Ensure child VSWs are on|off consistent with the PBSG state
  pbsg_ReconcileVswsToState(pbsg)
  // Invoke the client's callback function to consume the latest changes.
  pbsg_ButtonOnCallback(pbsg)
}

void reconcileVswsToState() {
  // Assumed: pbsg != null
  // The supplied PBSG is used without making any changes to its state.
  // Get or Create the child VSW for each button.
  Map buttonToVsw = [:]
  state.buttons.each{ button ->
    String dni = "${state.name}_${button}"
    buttonToVsw << [ (button) : getOrCreateDevice(dni) ]
  }
  // Ensure VSW state matches button state.
  buttonToVsw.each{ button, vsw ->
    if (state.active == button) {
      if ( switchState(vsw) != 'on') { vsw.on() }
    } else {
      if ( switchState(vsw) != 'off') { vsw.off() }
    }
  }
}

boolean activateLastActive() {
  // Assumed: pbsg != null
  // -----------------------------------------------------------------
  // I M P O R T A N T   (circa Q2'24)
  //   The Groovy ListArray implementation operates in reverse order
  //     - push(item) APPENDS the item to [] instead of PREPENDING it
  //     - pop() retrieves the last item pushed, at 'lifo.size() - 1'
  //       rather than position '0' per current Groovy docs.
  // -----------------------------------------------------------------
  Integer latestPushIndex = state.lifo.size() - 1
  return activateButton(state.lifo[latestPushIndex])
}

boolean enforceDefault() {
  // Assumed: pbsg != null
  // Returns true on a PBSG state change
  boolean result = false
  if (pbsg && !state.active && state.dflt) {
    logInfo('enforceDefault', "Activating default ${b(state.dflt)}")
    result = activateButton(state.dflt)
  }
  return result
}

String buttonState(String button) {
  // Assumed: pbsg != null
  // The supplied PBSG is used without making any changes to its state.
  if (button != null) {
    String tag = (button == state.dflt) ? '*' : ''
    String summary = "${tag}<b>${button}</b> "
    DevW vsw = getChildDevice("${state.name}_${button}")
    String swState = switchState(vsw)
      ?: logError('buttonState', "switchState() failed for button (${button}).")
    if (swState == 'on') {
      summary += '(<b>on</b>)'
    } else if (swState == 'off') {
      summary += '(<em>off</em>)'
    } else {
      logError('buttonState', "Encountered swState: >${swState}<")
      summary += '(--)'
    }
  } else {
    logError('buttonState', 'button arg is NULL')
  }
}

String pbsgState() {
  // Assumed: pbsg != null
  // The supplied PBSG is used without making any changes to its state.
  //   IMPORTANT:
  //     LIFO push() and pop() are supported, *BUT* pushed items are
  //     appended (NOTE PREPENDED); so, the list needs to be reverse
  //     to look like a FIFO.
  String result
  if (pbsg) {
    result = "${b(state.name)}: "
    result += (state.active) ? "${buttonState(state.active)} " : ''
    result += '← ['
    result += state.lifo.reverse().collect { button -> buttonState(button) }.join(', ')
    result += ']'
  } else {
    logError('pbsgState', 'Received null PBSG parameter.')
  }
  return result
}

/*
void childVswEventHandler(Event e) {
  // This handler processes VSW changes, including:
  //   - Changes made by this application - see reconcileVswsToState()
  //   - Changes made externally by the Hubitat GUI, Alexa, etc.
  // An event's displayName (e.displayName) is the "name" of the VSW
  // which differs from the Device Network Id (DNI). Some care is
  // required when tokenizing e.displayName.
  //     Name Format: '${pbsgInstName} ${buttonName}'  ← note whitespace
  //      DNI Format: '${pbsgInstName}_${buttonName}'  ← note underscore
  // Some external sources generate back-to-back events:
  //   - Lutron RadioRA (RA2) turns off one scene BEFORE turning on
  //     the replacement scene.
  //   - Lutron Caséta (PRO2) turns on scenes without turning off
  //     predecessors.
  // When this method makes a change to a PBSG instance, it commits
  // changes to atomicState using syncVswsAndIssueCallback() which ensures changes
  // are reported to the client's callback function.
  if (e.name == 'switch') {
    ArrayList parsedName = e.displayName.tokenize(' ')
    String pbsgName = parsedName[0]
    String button = parsedName[1]
    Map pbsg = getPbsgState(pbsgName)
    switch (e.value) {
      case 'on':
        if (state.active != button) {
          // This reported event differs from the current PBSG state.
          logInfo(
            'childVswEventHandler',
            "${b(button)} VSW turned on .. activating")
          activateButton(button) && syncVswsAndIssueCallback()
        } else {
          logTrace('childVswEventHandler', "Ignoring ${b(button)} turned on")
        }
        break
      case 'off':
        if (state.lifo.contains(button)) {
          logTrace('childVswEventHandler', "Ignoring ${b(button)} turned off")
        } else {
          // This reported event differs from the current PBSG state.
          logInfo(
            'childVswEventHandler',
            "${b(button)} VSW turned off .. deactivating")
          deactivateButton(button) && syncVswsAndIssueCallback()
        }
        break
      default:
        logError('childVswEventHandler', ['',
          e.descriptionText,
          "Unexpected e.value: ${b(e.value)}",
          eventDetails(e)
        ].join('<br/>'))
    }
  } else {
    logTrace(
      'childVswEventHandler',
      "Ignoring ${eventDetails(e)}"
    )
  }
}
*/
